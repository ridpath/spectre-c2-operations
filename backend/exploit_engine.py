from typing import Dict, Any, List, Optional, Callable
from datetime import datetime, timezone
from sqlalchemy.orm import Session
from models import Mission, AttackStep, Evidence, Vulnerability, StepStatus
import uuid
import asyncio


class ExploitEngine:
    def __init__(self, db: Session):
        self.db = db
        self.running_exploits: Dict[str, bool] = {}
        
    async def execute_step(
        self,
        step: AttackStep,
        mission: Mission,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        step.status = StepStatus.EXECUTING
        step.started_at = datetime.now(timezone.utc)
        self.db.commit()
        
        try:
            if step.tool == "scanner":
                result = await self._execute_scanner(step, mission, context)
            elif step.tool == "exploit":
                result = await self._execute_exploit(step, mission, context)
            elif step.tool == "command":
                result = await self._execute_command(step, mission, context)
            else:
                result = {"status": "error", "message": f"Unknown tool: {step.tool}"}
            
            step.actual_result = str(result)
            step.status = StepStatus.COMPLETED if result.get("status") == "success" else StepStatus.FAILED
            step.completed_at = datetime.now(timezone.utc)
            
            return result
            
        except Exception as e:
            step.actual_result = f"Execution error: {str(e)}"
            step.status = StepStatus.FAILED
            step.completed_at = datetime.now(timezone.utc)
            return {"status": "error", "message": str(e)}
        finally:
            self.db.commit()
    
    async def _execute_scanner(
        self,
        step: AttackStep,
        mission: Mission,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        await asyncio.sleep(1)
        
        return {
            "status": "success",
            "vulnerabilities_found": 2,
            "message": "Vulnerability scan completed"
        }
    
    async def _execute_exploit(
        self,
        step: AttackStep,
        mission: Mission,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        await asyncio.sleep(2)
        
        vuln = self.db.query(Vulnerability).filter(
            Vulnerability.norad_id == mission.target_norad_id
        ).first()
        
        if not vuln or not vuln.exploit_available:
            return {
                "status": "error",
                "message": "No exploitable vulnerability found"
            }
        
        evidence = Evidence(
            id=uuid.uuid4(),
            mission_id=mission.id,
            category="command_output",
            description=f"Exploit execution: {vuln.cve}",
            data=f"Successfully exploited {vuln.cve} - {vuln.description}",
            metadata={"vulnerability_id": str(vuln.id), "cvss": vuln.cvss_score},
            tags=["exploit", vuln.severity.value]
        )
        self.db.add(evidence)
        self.db.commit()
        
        return {
            "status": "success",
            "cve": vuln.cve,
            "message": "Exploit executed successfully",
            "evidence_id": str(evidence.id)
        }
    
    async def _execute_command(
        self,
        step: AttackStep,
        mission: Mission,
        context: Dict[str, Any]
    ) -> Dict[str, Any]:
        await asyncio.sleep(0.5)
        
        return {
            "status": "success",
            "output": f"Command '{step.command}' executed",
            "message": "Command completed"
        }
    
    async def execute_playbook(
        self,
        playbook_steps: List[Dict[str, Any]],
        mission: Mission,
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        if context is None:
            context = {}
        
        execution_id = str(uuid.uuid4())
        self.running_exploits[execution_id] = True
        
        results = []
        failed = False
        
        for step_data in playbook_steps:
            if not self.running_exploits.get(execution_id, False):
                break
            
            step = AttackStep(
                id=uuid.uuid4(),
                mission_id=mission.id,
                phase=step_data.get("phase", "execution"),
                tool=step_data.get("tool", "command"),
                command=step_data.get("command", ""),
                expected_result=step_data.get("expected_result", ""),
                status=StepStatus.PENDING
            )
            
            self.db.add(step)
            self.db.commit()
            
            result = await self.execute_step(step, mission, context)
            results.append({
                "step_id": str(step.id),
                "status": result.get("status"),
                "result": result
            })
            
            if result.get("status") != "success":
                failed = True
                break
        
        del self.running_exploits[execution_id]
        
        return {
            "execution_id": execution_id,
            "status": "failed" if failed else "completed",
            "steps_executed": len(results),
            "results": results
        }
    
    def stop_execution(self, execution_id: str):
        if execution_id in self.running_exploits:
            self.running_exploits[execution_id] = False


class MissionAutomation:
    def __init__(self, db: Session, exploit_engine: ExploitEngine):
        self.db = db
        self.exploit_engine = exploit_engine
        self.active_missions: Dict[str, asyncio.Task] = {}
    
    async def schedule_mission(self, mission: Mission, aos_time: datetime):
        wait_seconds = (aos_time - datetime.now(timezone.utc)).total_seconds()
        
        if wait_seconds > 0:
            await asyncio.sleep(wait_seconds)
        
        mission.status = "active"
        mission.started_at = datetime.now(timezone.utc)
        self.db.commit()
        
        if mission.attack_chain:
            result = await self.exploit_engine.execute_playbook(
                mission.attack_chain,
                mission
            )
            
            mission.status = "completed" if result["status"] == "completed" else "aborted"
            mission.completed_at = datetime.now(timezone.utc)
            self.db.commit()
    
    def start_automated_mission(self, mission_id: str, aos_time: datetime):
        mission = self.db.query(Mission).filter(Mission.id == uuid.UUID(mission_id)).first()
        if not mission:
            return False
        
        task = asyncio.create_task(self.schedule_mission(mission, aos_time))
        self.active_missions[mission_id] = task
        return True
    
    def cancel_automated_mission(self, mission_id: str):
        if mission_id in self.active_missions:
            self.active_missions[mission_id].cancel()
            del self.active_missions[mission_id]
            return True
        return False


class EvidenceCollector:
    def __init__(self, db: Session):
        self.db = db
    
    def capture_command_output(
        self,
        mission_id: uuid.UUID,
        command: str,
        output: str,
        metadata: Dict[str, Any] = None
    ) -> Evidence:
        evidence = Evidence(
            id=uuid.uuid4(),
            mission_id=mission_id,
            category="command_output",
            description=f"Command execution: {command[:100]}",
            data=output,
            metadata=metadata or {},
            tags=["command", "automated"]
        )
        
        self.db.add(evidence)
        self.db.commit()
        return evidence
    
    def capture_signal(
        self,
        mission_id: uuid.UUID,
        frequency: float,
        signal_strength: float,
        signal_data: str,
        satellite_name: str
    ) -> Evidence:
        evidence = Evidence(
            id=uuid.uuid4(),
            mission_id=mission_id,
            category="signal_recording",
            description=f"Signal capture at {frequency} MHz",
            data=signal_data,
            frequency=frequency,
            signal_strength=signal_strength,
            satellite_name=satellite_name,
            metadata={"frequency_mhz": frequency, "strength_dbm": signal_strength},
            tags=["signal", "automated"]
        )
        
        self.db.add(evidence)
        self.db.commit()
        return evidence
    
    def capture_packet(
        self,
        mission_id: uuid.UUID,
        packet_data: bytes,
        protocol: str,
        metadata: Dict[str, Any] = None
    ) -> Evidence:
        evidence = Evidence(
            id=uuid.uuid4(),
            mission_id=mission_id,
            category="packet_capture",
            description=f"{protocol} packet capture",
            data=packet_data.hex(),
            metadata=metadata or {"protocol": protocol},
            tags=["packet", protocol.lower(), "automated"]
        )
        
        self.db.add(evidence)
        self.db.commit()
        return evidence
